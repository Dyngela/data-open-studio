func {{ .FuncName }}(ctx context.Context, leftIn <-chan *{{ .LeftType }}, rightIn <-chan *{{ .RightType }}, outChan chan<- *{{ .OutputType }}, progress lib.ProgressFunc) error {
	var rowCount int64

	// Report start
	if progress != nil {
		progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusRunning, 0, "starting inner join"))
	}

	// Build right index
	rightIndex := make(map[string]*{{ .RightType }})
	for r := range rightIn {
		key := {{ range $i, $k := .RightKeys }}{{ if $i }} + "|" + {{ end }}fmt.Sprintf("%v", r.{{ $k }}){{ end }}
		rightIndex[key] = r
	}

	// Process left stream, only emit matches
	for left := range leftIn {
		key := {{ range $i, $k := .LeftKeys }}{{ if $i }} + "|" + {{ end }}fmt.Sprintf("%v", left.{{ $k }}){{ end }}
		right, ok := rightIndex[key]
		if !ok {
			continue // Skip non-matching rows
		}
{{- if .VariablesCode }}
{{ .VariablesCode }}
{{- else if .FilterExpr }}

		// Global filter
		if !({{ .FilterExpr }}) {
			continue
		}
{{- end }}

		out := &{{ .OutputType }}{}
{{ .Transforms }}
		rowCount++

		// Report progress every 1000 rows
		if progress != nil && rowCount % 1000 == 0 {
			progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusRunning, rowCount, fmt.Sprintf("joined %d rows", rowCount)))
		}

		select {
		case outChan <- out:
		case <-ctx.Done():
			return ctx.Err()
		}
	}

	// Report completion
	if progress != nil {
		progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusCompleted, rowCount, "completed"))
	}

	return nil
}
