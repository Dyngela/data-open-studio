func {{ .FuncName }}(ctx context.Context, leftIn <-chan *{{ .LeftType }}, rightIn <-chan *{{ .RightType }}, outChan chan<- *{{ .OutputType }}, progress lib.ProgressFunc) error {
	var rowCount int64

	// Report start
	if progress != nil {
		progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusRunning, 0, "starting cross join"))
	}

	// Collect all right rows
	var rightRows []*{{ .RightType }}
	for r := range rightIn {
		rightRows = append(rightRows, r)
	}

	// Cross product
	for left := range leftIn {
		for _, right := range rightRows {
			out := &{{ .OutputType }}{}
{{ .Transforms }}
			rowCount++

			// Report progress every 1000 rows
			if progress != nil && rowCount % 1000 == 0 {
				progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusRunning, rowCount, fmt.Sprintf("joined %d rows", rowCount)))
			}

			select {
			case outChan <- out:
			case <-ctx.Done():
				return ctx.Err()
			}
		}
	}

	// Report completion
	if progress != nil {
		progress(lib.NewProgress({{ .NodeID }}, "{{ .NodeName }}", lib.StatusCompleted, rowCount, "completed"))
	}

	return nil
}
