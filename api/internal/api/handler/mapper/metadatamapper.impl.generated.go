// Code generated by dtomapper -type=MetadataMapper; DO NOT EDIT.

package mapper

import (
	"api/internal/api/handler/request"
	"api/internal/api/handler/response"
	"api/internal/api/models"
)

// MetadataMapperImpl implements MetadataMapper
type MetadataMapperImpl struct{}

// NewMetadataMapper creates a new instance of MetadataMapperImpl
func NewMetadataMapper() MetadataMapper {
	return &MetadataMapperImpl{}
}

// ToMetadataResponses  Database metadata
func (mapper *MetadataMapperImpl) ToMetadataResponses(entities []models.MetadataDatabase) []response.Metadata {
	result := make([]response.Metadata, len(entities))
	for i, item := range entities {
		result[i] = mapper.ToMetadataResponse(item)
	}
	return result

}

// ToMetadataResponse
func (mapper *MetadataMapperImpl) ToMetadataResponse(m models.MetadataDatabase) response.Metadata {
	var result response.Metadata
	result.ID = m.ID
	result.Host = m.Host
	result.Port = m.Port
	result.User = m.User
	result.Password = m.Password
	result.DatabaseName = m.DatabaseName
	result.SSLMode = m.SSLMode
	result.Extra = m.Extra
	result.DbType = m.DbType
	return result

}

// CreateDbMetadata
func (mapper *MetadataMapperImpl) CreateDbMetadata(req request.CreateMetadata) models.MetadataDatabase {
	var result models.MetadataDatabase
	result.Host = req.Host
	result.Port = req.Port
	result.User = req.User
	result.Password = req.Password
	result.DatabaseName = req.DatabaseName
	result.SSLMode = req.SSLMode
	result.DbType = models.DBType(req.DbType)
	return result

}

// UpdateDbMetadata  update
func (mapper *MetadataMapperImpl) UpdateDbMetadata(req request.UpdateMetadata, m *models.MetadataDatabase) {
	if req.Host != nil {
		m.Host = *req.Host
	}
	if req.Port != nil {
		m.Port = *req.Port
	}
	if req.User != nil {
		m.User = *req.User
	}
	if req.Password != nil {
		m.Password = *req.Password
	}
	if req.DatabaseName != nil {
		m.DatabaseName = *req.DatabaseName
	}
	if req.SSLMode != nil {
		m.SSLMode = *req.SSLMode
	}
	if req.DbType != nil {
		m.DbType = models.DBType(*req.DbType)
	}

}

// PatchDbMetadata  patch
func (mapper *MetadataMapperImpl) PatchDbMetadata(req request.UpdateMetadata) map[string]any {
	result := make(map[string]any)
	if req.Host != nil {
		result["host"] = *req.Host
	}
	if req.Port != nil {
		result["port"] = *req.Port
	}
	if req.User != nil {
		result["user"] = *req.User
	}
	if req.Password != nil {
		result["password"] = *req.Password
	}
	if req.DatabaseName != nil {
		result["database_name"] = *req.DatabaseName
	}
	if req.SSLMode != nil {
		result["ssl_mode"] = *req.SSLMode
	}
	if req.DbType != nil {
		result["db_type"] = *req.DbType
	}
	return result

}

// ToSftpMetadataResponses  SFTP metadata
func (mapper *MetadataMapperImpl) ToSftpMetadataResponses(entities []models.MetadataSftp) []response.SftpMetadata {
	result := make([]response.SftpMetadata, len(entities))
	for i, item := range entities {
		result[i] = mapper.ToSftpMetadataResponse(item)
	}
	return result

}

// ToSftpMetadataResponse
func (mapper *MetadataMapperImpl) ToSftpMetadataResponse(m models.MetadataSftp) response.SftpMetadata {
	var result response.SftpMetadata
	result.ID = m.ID
	result.Host = m.Host
	result.Port = m.Port
	result.User = m.User
	result.Password = m.Password
	result.PrivateKey = m.PrivateKey
	result.BasePath = m.BasePath
	result.Extra = m.Extra
	return result

}

// CreateSftpMetadata
func (mapper *MetadataMapperImpl) CreateSftpMetadata(req request.CreateSftpMetadata) models.MetadataSftp {
	var result models.MetadataSftp
	result.Host = req.Host
	result.Port = req.Port
	result.User = req.User
	result.Password = req.Password
	result.PrivateKey = req.PrivateKey
	result.BasePath = req.BasePath
	result.Extra = req.Extra
	return result

}

// PatchSftpMetadata  patch
func (mapper *MetadataMapperImpl) PatchSftpMetadata(req request.UpdateSftpMetadata) map[string]any {
	result := make(map[string]any)
	if req.Host != nil {
		result["host"] = *req.Host
	}
	if req.Port != nil {
		result["port"] = *req.Port
	}
	if req.User != nil {
		result["user"] = *req.User
	}
	if req.Password != nil {
		result["password"] = *req.Password
	}
	if req.PrivateKey != nil {
		result["private_key"] = *req.PrivateKey
	}
	if req.BasePath != nil {
		result["base_path"] = *req.BasePath
	}
	if req.Extra != nil {
		result["extra"] = *req.Extra
	}
	return result

}

// ToEmailMetadataResponses  Email metadata
func (mapper *MetadataMapperImpl) ToEmailMetadataResponses(entities []models.MetadataEmail) []response.EmailMetadata {
	result := make([]response.EmailMetadata, len(entities))
	for i, item := range entities {
		result[i] = mapper.ToEmailMetadataResponse(item)
	}
	return result

}

// ToEmailMetadataResponse
func (mapper *MetadataMapperImpl) ToEmailMetadataResponse(m models.MetadataEmail) response.EmailMetadata {
	var result response.EmailMetadata
	result.ID = m.ID
	result.Name = m.Name
	result.ImapHost = m.ImapHost
	result.ImapPort = m.ImapPort
	result.SmtpHost = m.SmtpHost
	result.SmtpPort = m.SmtpPort
	result.Username = m.Username
	result.Password = m.Password
	result.UseTLS = m.UseTLS
	result.Extra = m.Extra
	return result

}

// CreateEmailMetadata
func (mapper *MetadataMapperImpl) CreateEmailMetadata(req request.CreateEmailMetadata) models.MetadataEmail {
	var result models.MetadataEmail
	result.Name = req.Name
	result.ImapHost = req.ImapHost
	result.ImapPort = req.ImapPort
	result.SmtpHost = req.SmtpHost
	result.SmtpPort = req.SmtpPort
	result.Username = req.Username
	result.Password = req.Password
	if req.UseTLS != nil {
		result.UseTLS = *req.UseTLS
	} else {
		result.UseTLS = true
	}
	result.Extra = req.Extra
	return result

}

// PatchEmailMetadata  patch
func (mapper *MetadataMapperImpl) PatchEmailMetadata(req request.UpdateEmailMetadata) map[string]any {
	result := make(map[string]any)
	if req.Name != nil {
		result["name"] = *req.Name
	}
	if req.ImapHost != nil {
		result["imap_host"] = *req.ImapHost
	}
	if req.ImapPort != nil {
		result["imap_port"] = *req.ImapPort
	}
	if req.SmtpHost != nil {
		result["smtp_host"] = *req.SmtpHost
	}
	if req.SmtpPort != nil {
		result["smtp_port"] = *req.SmtpPort
	}
	if req.Username != nil {
		result["username"] = *req.Username
	}
	if req.Password != nil {
		result["password"] = *req.Password
	}
	if req.UseTLS != nil {
		result["use_tls"] = *req.UseTLS
	}
	if req.Extra != nil {
		result["extra"] = *req.Extra
	}
	return result

}
