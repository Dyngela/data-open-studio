# DTO Mapper Generator

A code generation tool that creates mapper interface implementations with automatic field-by-field mapping, including special handling for update operations with pointer fields.

## Purpose

When working with DTOs (Data Transfer Objects) and domain models, you often need mapper functions to convert between them. This tool automates the generation of these mappers by:

- Parsing mapper interfaces
- Generating implementations with field-by-field mapping
- Handling pointer type conversions automatically
- Supporting partial updates with nil-checking for pointer fields (when tagged with `// --update`)
- Properly handling slice/array fields with TODO comments

## Usage

### 1. Define a Mapper Interface

Create a mapper interface with the methods you need. Add a `//go:generate` directive before it:

```go
package mapper

import (
    "core/internal/api/handler/request"
    "core/internal/api/handler/response"
    "core/internal/api/models"
)

//go:generate go run ../../../../tools/dtomapper -type=VehiculeMapper

// generate:dtomapper
type VehiculeMapper interface {
    // --update
    DtoToUpdate(req request.UpdateVehicleDTO) models.Vehicle
    DtoToCreate(req request.CreateVehicleDTO) models.Vehicle
    EntityToDto(models.Vehicle) response.VehicleResponse
}
```

### 2. Run Code Generation

```bash
cd path/to/mapper/package
go generate
```

This generates a file named `{interfacename}.impl.generated.go` (e.g., `vehiculemapper.impl.generated.go`).

### 3. Use the Generated Mapper

```go
mapper := mapper.NewVehiculeMapper()

// For updates (uses nil-checking for pointer fields)
vehicle := mapper.DtoToUpdate(updateDTO)

// For creation (direct mapping)
vehicle := mapper.DtoToCreate(createDTO)

// Entity to response DTO
response := mapper.EntityToDto(vehicle)
```

## Special Tags

### `// --update` Tag

Methods tagged with `// --update` will generate code that checks for nil before updating fields. This is useful for partial update operations where you only want to update fields that were explicitly provided.

**Example:**

```go
// --update
DtoToUpdate(req request.UpdateVehicleDTO) models.Vehicle
```

**Generated code:**

```go
func (m *VehiculeMapperImpl) DtoToUpdate(req request.UpdateVehicleDTO) models.Vehicle {
    var result models.Vehicle
    if req.ID != nil {
        result.ID = *req.ID
    }
    if req.Name != nil {
        result.Name = *req.Name
    }
    // ... more fields
    return result
}
```

## Generated Code Features

### Pointer Type Handling

The generator intelligently handles pointer type mismatches:

- **Both pointers**: Direct assignment (`result.Field = dto.Field`)
- **Source pointer, target not**: Dereference (`result.Field = *dto.Field`)
- **Source not pointer, target pointer**: Take address (`val := dto.Field; result.Field = &val`)
- **Neither pointer**: Direct assignment (`result.Field = dto.Field`)

### Slice Fields

Slice/array fields are marked with TODO comments, as they typically require custom business logic:

```go
// TODO: Handle slice field Photos manually
// TODO: Handle slice field Avaries manually
```

### Import Handling

The generator automatically copies imports from your interface file to the generated implementation.

## Generated File Structure

```go
// Code generated by dtomapper -type=VehiculeMapper; DO NOT EDIT.

package mapper

import (
    "core/internal/api/handler/request"
    "core/internal/api/handler/response"
    "core/internal/api/models"
)

// VehiculeMapperImpl implements VehiculeMapper
type VehiculeMapperImpl struct{}

// NewVehiculeMapper creates a new instance of VehiculeMapperImpl
func NewVehiculeMapper() VehiculeMapper {
    return &VehiculeMapperImpl{}
}

// ... method implementations
```

## How Field Mapping Works

1. The generator parses all structs in the current package and related packages (`request`, `response`, `models`)
2. For each method in the interface, it:
    - Identifies source and target struct types
    - Matches fields by name
    - Generates appropriate conversion code based on pointer status
    - Adds nil-checks for `--update` tagged methods
    - Marks slice fields with TODO comments

## Command Line Options

- `-type`: Required. The name of the mapper interface to generate implementation for.
- `-output`: Optional. The output filename. Defaults to `{typename}.impl.generated.go` in lowercase.

## Example: Complete Mapper Interface

```go
//go:generate go run ../../../../tools/dtomapper -type=UserMapper

// generate:dtomapper
type UserMapper interface {
    // --update
    UpdateDtoToEntity(dto request.UpdateUserDTO) models.User

    CreateDtoToEntity(dto request.CreateUserDTO) models.User

    EntityToResponse(user models.User) response.UserResponse

    EntitiesToResponses(users []models.User) []response.UserResponse
}
```

## Limitations

1. **Slice/Array fields**: Not automatically mapped. Requires manual implementation.
2. **Nested structs**: Simple field-by-field mapping only. Complex nested structures may need manual handling.
3. **Package resolution**: Related packages are expected to be in `../request`, `../response`, `../models`, or `../../models`.
4. **Field matching**: Based on exact name matching. Fields with different names won't be mapped.

## Tips

- Keep DTOs and models with similar field names for automatic mapping
- Use pointer fields in update DTOs to distinguish between "not provided" and "zero value"
- Tag update methods with `// --update` to enable nil-checking
- Handle slice fields manually after the generated mapper completes basic field mapping
- Re-run `go generate` whenever you modify the interface or struct definitions
